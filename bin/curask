#!/usr/bin/env python3
"""
curask - Send message to Cursor Agent and wait for reply.

Designed to be used with Claude Code's run_in_background=true.
If --output is provided, the reply is written atomically to that file and stdout stays empty.
"""

from __future__ import annotations

import json
import os
import re
import secrets
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional, Tuple

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding

setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_OK, atomic_write_text

CACHE_DIR = Path(
    os.environ.get("CCB_DELEGATION_CACHE_DIR")
    or (Path.home() / ".cache" / "ccb" / "delegation")
)

ASYNC_GUARDRAIL = """[CCB_ASYNC_SUBMITTED provider=cursor]
IMPORTANT: Task submitted to Cursor. You MUST:
1. Tell user "Cursor processing..."
2. END YOUR TURN IMMEDIATELY
3. Do NOT wait, poll, check status, or use any more tools
"""


def _usage() -> None:
    print(
        "Usage: curask [--resume <chatId>] [--no-force] [--output FILE] [--model MODEL] [--timeout SEC] [--sync] <message>",
        file=sys.stderr,
    )
    print("", file=sys.stderr)
    print("Options:", file=sys.stderr)
    print("  --resume <chatId>  Resume a previous session by chat ID", file=sys.stderr)
    print("  --no-force         Disable file editing (default: editing enabled)", file=sys.stderr)
    print("  --output FILE      Write output to FILE (for background mode)", file=sys.stderr)
    print("  --model MODEL      Specify model to use", file=sys.stderr)
    print("  --timeout SEC      Timeout in seconds (default: 300)", file=sys.stderr)
    print("  --sync             Sync mode (no async guardrail)", file=sys.stderr)
    print("  -q, --quiet        Suppress progress messages", file=sys.stderr)


def _parse_args(argv: list[str]) -> Tuple[
    Optional[Path],  # output
    float,           # timeout
    str,             # message
    bool,            # quiet
    bool,            # sync_mode
    bool,            # force (allow file editing)
    Optional[str],   # resume (chat_id)
    Optional[str],   # model
]:
    output: Optional[Path] = None
    timeout: Optional[float] = None
    quiet = False
    sync_mode = False
    force = True  # Default: force enabled
    resume: Optional[str] = None
    model: Optional[str] = None
    parts: list[str] = []

    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            raise SystemExit(0)
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token == "--sync":
            sync_mode = True
            continue
        if token == "--no-force":
            force = False
            continue
        if token == "--resume":
            try:
                resume = next(it)
            except StopIteration:
                raise ValueError("--resume requires a chat ID")
            continue
        if token == "--model":
            try:
                model = next(it)
            except StopIteration:
                raise ValueError("--model requires a model name")
            continue
        if token in ("-o", "--output"):
            try:
                output = Path(next(it)).expanduser()
            except StopIteration:
                raise ValueError("--output requires a file path")
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                raise ValueError("--timeout requires a number")
            except ValueError as exc:
                raise ValueError(f"Invalid --timeout: {exc}")
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_CURSOR_TIMEOUT", "300"))
        except Exception:
            timeout = 300.0
    return output, timeout, message, quiet, sync_mode, force, resume, model


def _make_task_id() -> str:
    ts = int(time.time())
    rand = secrets.token_hex(2)
    return f"cursor-{ts}-{rand}"


def _write_meta(task_id: str, meta: dict) -> None:
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    meta_path = CACHE_DIR / f"{task_id}.json"
    try:
        meta_path.write_text(json.dumps(meta, ensure_ascii=True), encoding="utf-8")
    except Exception:
        pass


def _extract_chat_id(output: str) -> Optional[str]:
    """Extract chat_id from cursor-agent output if present."""
    # Look for UUID pattern that might be a chatId
    patterns = [
        r'"chatId":\s*"([a-f0-9-]{36})"',
        r'chatId:\s*([a-f0-9-]{36})',
        r'chat[_-]?id[=:]\s*([a-f0-9-]{36})',
    ]
    for pattern in patterns:
        match = re.search(pattern, output, re.IGNORECASE)
        if match:
            return match.group(1)
    return None


def main(argv: list[str]) -> int:
    try:
        output_path, timeout, message, quiet, sync_mode, force, resume, model = _parse_args(argv)
        if not message and not sys.stdin.isatty():
            message = read_stdin_text().strip()
        if not message:
            _usage()
            return EXIT_ERROR

        # Build cursor-agent command
        cmd = ["cursor-agent"]

        if force:
            cmd.append("--force")

        if resume:
            cmd.extend(["--resume", resume])

        if model:
            cmd.extend(["--model", model])

        # Add the message
        cmd.append(message)

        task_id = _make_task_id()
        out_path = output_path or (CACHE_DIR / f"{task_id}.out")

        # Write initial metadata
        meta = {
            "task_id": task_id,
            "provider": "cursor",
            "output_file": str(out_path),
            "status": "running",
            "started_at": int(time.time()),
            "force": force,
            "resume": resume,
            "model": model,
        }
        _write_meta(task_id, meta)

        if not quiet:
            print(f"[curask] Running cursor-agent...", file=sys.stderr)

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
            )
            reply = result.stdout.strip()
            stderr_out = result.stderr.strip()
            exit_code = result.returncode

            # Try to extract chat_id for resume capability
            chat_id = _extract_chat_id(reply) or _extract_chat_id(stderr_out)

            # Update metadata
            meta["status"] = "completed" if exit_code == 0 else "error"
            meta["exit_code"] = exit_code
            meta["finished_at"] = int(time.time())
            if chat_id:
                meta["chat_id"] = chat_id
            _write_meta(task_id, meta)

            # Inject guardrail prompt (skip in sync mode)
            if not sync_mode:
                print(ASYNC_GUARDRAIL, file=sys.stderr, flush=True)

            # Always write to cache for curpend retrieval
            # (out_path == output_path when user specified --output, otherwise it's the cache path)
            atomic_write_text(out_path, reply + "\n")

            # Only output to stdout if no --output was specified
            if not output_path:
                sys.stdout.write(reply)
                if not reply.endswith("\n"):
                    sys.stdout.write("\n")

            if stderr_out and not quiet:
                print(f"[stderr] {stderr_out}", file=sys.stderr)

            return exit_code

        except subprocess.TimeoutExpired:
            meta["status"] = "error"
            meta["error"] = "timeout"
            meta["finished_at"] = int(time.time())
            _write_meta(task_id, meta)
            print(f"[ERROR] cursor-agent timed out after {timeout}s", file=sys.stderr)
            return EXIT_ERROR

    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        print(f"[ERROR] {exc}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
